
- [分布式理论](#分布式理论)
  - [CAP](#cap)
  - [BASE](#base)
  - [柔性事务和刚性事务](#柔性事务和刚性事务)
  - [一致性](#一致性)
- [分布式事务](#分布式事务)
  - [2PC 和 3PC](#2pc-和-3pc)
    - [2PC重要组件 (Seata的TA模式)](#2pc重要组件-seata的ta模式)
  - [TCC](#tcc)
  - [分布式一致性算法](#分布式一致性算法)
    - [Paxos](#paxos)
    - [Raft（muti-paxos）](#raftmuti-paxos)
    - [ZAB（muti-paxos）](#zabmuti-paxos)

# 分布式理论

## CAP

CAP 分布式 CAP 理论，任何一个分布式系统都无法同时满足 Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性） 这三个基本需求。最多只能满足其中两项。而 Partition tolerance（分区容错性） 是必须的，因此一般是 CP ，或者 AP

## BASE

Basically Available（基本可用）
分布式系统在出现不可预知故障的时候，允许损失部分可用性
Soft state（软状态）
软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。
Eventually consistent（最终一致性）
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性
CAP 与 BASE 关系为：

在分布式的数据系统中，你能保证下面三个要求中的两个：一致性，可用性，以及分区容错性。在此模型上构建的系统将称作 BASE(基本上可用软状态最终一致)架构，不满足 ACID 性质。

## 柔性事务和刚性事务

刚性事务满足ACID理论
柔性事务满足BASE理论（基本可用，最终一致）

## 一致性

数据一致性通常指关联数据之间的逻辑关系是否正确和完整。在分布式系统中，数据一致性往往指的是由于数据的复制，不同数据节点中的数据内容是否完整并且相同。

一致性还分为强一致性，弱一致性，还有最终一致性。强一致性就是马上就保持一致。

最终一致性是指经过一段时间后，可以保持一致。

# 分布式事务

## 2PC 和 3PC

分布式事务是指会涉及到操作多个数据库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务类型：二阶段提交 2PC ，三阶段提交 3PC。

2PC ：第一阶段：准备阶段（投票阶段）和第二阶段：提交阶段（执行阶段）。


3PC ：三个阶段：CanCommit 、PreCommit 、DoCommit。

### 2PC重要组件 (Seata的TA模式)

事务协调器 TC
维护全局和分支事务的状态，指示全局提交或者回滚。

事务管理者 TM
开启、提交或者回滚一个全局事务。

资源管理者 RM
管理执行分支事务的那些资源，向TC注册分支事务、上报分支事务状态、控制分支事务的提交或者回滚。

TM 请求 TC，开始一个新的全局事务，TC 会为这个全局事务生成一个 XID。
XID 通过微服务的调用链传递到其他微服务。
RM 把本地事务作为这个XID的分支事务注册到TC。
TM 请求 TC 对这个 XID 进行提交或回滚。
TC 指挥这个 XID 下面的所有分支事务进行提交、回滚。

## TCC

**T（Try）** 
锁资源：锁定某个资源，设置一个预备类的状态，冻结部分数据。

比如，订单的支付状态，先把状态修改为"支付中（PAYING）"。
比如，本来库存数量是 100 ，现在卖出了 2 个，不要直接扣减这个库存。在一个单独的冻结库存的字段，比如 prepare_remove_stock 字段，设置一个 2。也就是说，有 2 个库存是给冻结了。
积分服务的也是同理，别直接给用户增加会员积分。你可以先在积分表里的一个预增加积分字段加入积分。
比如：用户积分原本是 1190 ，现在要增加 10 个积分，别直接 1190 + 10 = 1200 个积分啊！你可以保持积分为 1190 不变，在一个预增加字段里，比如说 prepare_add_credit 字段，设置一个 10 ，表示有 10 个积分准备增加。

**C（Confirm）**：在各个服务里引入了一个 TCC 分布式事务的框架，事务管理器可以感知到各个服务的 Try 操作是否都成功了。假如都成功了， TCC 分布式事务框架会控制进入 TCC 下一个阶段，第一个 C 阶段，也就是 Confirm 阶段。此时，需要把 Try 阶段锁住的资源进行处理。

比如，把订单的状态设置为“已支付（Payed）”。
比如，扣除掉相应的库存。
比如，增加用户积分。

**C（Cancel）**：在 Try 阶段，假如某个服务执行出错，比如积分服务执行出错了，那么服务内的 TCC 事务框架是可以感知到的，然后它会决定对整个 TCC 分布式事务进行回滚。

TCC 分布式事务框架只要感知到了任何一个服务的 Try 逻辑失败了，就会跟各个服务内的 TCC 分布式事务框架进行通信，然后调用各个服务的 Cancel 逻辑。也就是说，会执行各个服务的第二个 C 阶段， Cancel 阶段。

比如，订单的支付状态，先把状态修改为" closed "状态。
比如，冻结库存的字段， prepare_remove_stock 字段，将冻结的库存 2 清零。
比如，预增加积分的字段， prepare_add_credit 字段，将准备增加的积分 10 清零。

## 分布式一致性算法

### Paxos

Proposal提案，即分布式系统的修改请求，可以表示为[提案编号N，提案内容value]
Client用户，类似社会民众，负责提出建议
Proposer议员，类似基层人大代表，负责帮Client上交提案
Acceptor投票者，类似全国人大代表，负责为提案投票，不同意比自己以前接收过的提案编号要小的提案，其他提案都同意，例如A以前给N号提案表决过，那么再收到小于等于N号的提案时就直接拒绝了
Learner提案接受者，类似记录被通过提案的记录员，负责记录提案

### Raft（muti-paxos）

说明：Paxos算法不容易实现，Raft算法是对Paxos算法的简化和改进
概念介绍
Leader总统节点，负责发出提案
Follower追随者节点，负责同意Leader发出的提案
Candidate候选人，负责争夺Leader

Raft算法将一致性问题分解为两个的子问题，Leader选举和状态复制
**Leader选举**
每个Follower都持有一个定时器

当定时器时间到了而集群中仍然没有Leader，Follower将声明自己是Candidate并参与Leader选举，同时将消息发给其他节点来争取他们的投票，若其他节点长时间没有响应Candidate将重新发送选举信息

获得多数派支持的Candidate将成为第M任Leader（M任是最新的任期）

在任期内的Leader会不断发送心跳给其他节点证明自己还活着，其他节点受到心跳以后就清空自己的计时器并回复Leader的心跳。这个机制保证其他节点不会在Leader任期内参加Leader选举。

当Leader节点出现故障而导致Leader失联，没有接收到心跳的Follower节点将准备成为Candidate进入下一轮Leader选举
若出现两个Candidate同时选举并获得了相同的票数，那么这两个Candidate将随机推迟一段时间后再向其他节点发出投票请求，这保证了再次发送投票请求以后不冲突
**状态复制**

Leader负责接收来自Client的提案请求（红色提案表示未确认）

提案内容将包含在Leader发出的下一个心跳中

若集群中出现网络异常，导致集群被分割，将出现多个Leader

被分割出的非多数派集群将无法达到共识，即脑裂，如图中的A、B节点将无法确认提案

当集群再次连通时，将只听从最新任期Leader的指挥，旧Leader将退化为Follower，如图中B节点的Leader（任期1）需要听从D节点的Leader（任期2）的指挥，此时集群重新达到一致性状态

### ZAB（muti-paxos）

说明：ZAB也是对Multi Paxos算法的改进，大部分和raft相同
和raft算法的主要区别：
对于Leader的任期，raft叫做term，而ZAB叫做epoch
在状态复制的过程中，raft的心跳从Leader向Follower发送，而ZAB则相反。

其他详见 zookeeper atomic broadcast