
- [为何使用消息队列](#为何使用消息队列)
  - [异步](#异步)
  - [削峰](#削峰)
  - [解耦](#解耦)
- [主要问题](#主要问题)
  - [可用性](#可用性)
  - [重复消费](#重复消费)
 
## 为何使用消息队列
### 异步
用户响应时间随着链路越长变得越长 可以抽取部分流程异步完成 不使用线程池的原因是可以关注于自己开发的部分 更加易于维护
### 削峰
把请求放到队列中 慢慢处理
### 解耦
对于消息队列两端的代码可以解耦。
## 主要问题
### 可用性
一般的消息队列中间件都提供了高可用
比如kafka和RocketMQ
Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Master发送心跳。Producer只能将消息发送到Broker master。
Consumer则不一样，它同时与提供Topic服务的Master、Slave建立长连接，既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。

Zookeeper的的作用与NameServer的作用相似， 用于保存集群配置、选举Leader等。
集群中有许多broker用于堆积消息，Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高。
Producer使用push模式将消息发布到broker。
Consumer使用pull模式从broker订阅并消费消息
### 重复消费
现在消息队列一般都能保证at least once的，也就是消息至少一次投递。
在这种情况为什么会出现重复消费的问题呢？
通常都是由于网络原因造成的，原因如下：
通常消息被成功消费后消费者都会发送一个成功标志给MQ，MQ收到这个标志就表示消息已经成功消费了，就不会在发送给其他消费者了。
但是如果因为网络这个标志没有送到MQ就丢失了，MQ就认为这个消息没有被成功消费，就会再次发送给其他消费者消费，就造成了重复了。

